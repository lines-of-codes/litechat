import type { Component } from "mithril";
import m from "mithril";
import { ASYMMETRIC_KEY_ALG, getKey, SYMMETRIC_KEY_ALG } from "../crypto";
import pb, { thisUserId } from "../pocketbase";
import { BatchService } from "pocketbase";
import { arrayBufferToBase64 } from "../utils/base64";

let privKey: CryptoKey;
let jwk: string;
let requestBatch: BatchService;

function generateOTP(length: number) {
	const characters =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	const charactersLength = characters.length;
	let result = "";
	for (let i = 0; i < length; i++) {
		result += characters.charAt(Math.random() * charactersLength);
	}
	return result;
}

type KeyType = "RSA-OAEP" | "AES-GCM" | "PBKDF2";
async function registerKey(params: {
	key: string;
	keyType: KeyType;
	encryptionKey: CryptoKey;
	relatedChat?: string;
	oneTime?: boolean;
}) {
	const enc = new TextEncoder();
	const iv = crypto.getRandomValues(new Uint8Array(12));
	const encryptedKey = await crypto.subtle.encrypt(
		{
			name: "AES-GCM",
			iv,
		} as AesGcmParams,
		params.encryptionKey,
		enc.encode(params.key)
	);

	requestBatch.collection("keystore").create({
		owner: thisUserId,
		key: arrayBufferToBase64(encryptedKey),
		type: params.keyType,
		relatedChat: params.relatedChat,
		oneTime: params.oneTime ?? true,
		iv: JSON.stringify(Array.from(iv)),
	});
}

async function useKeystore() {
	let password = prompt(
		"Please enter a password to protect your keys. (Leave empty for an autogenerated password), and do not leave this page until you have been notified of the result."
	);
	let oneTime = true;

	if (password === null || password === "") {
		password = generateOTP(6);
		alert(
			`Your randomly generated password is: "${password}". Please copy it. Note that this is only usable once.`
		);
	}

	const enc = new TextEncoder();
	const passwordKey = await crypto.subtle.importKey(
		"raw",
		enc.encode(password),
		"PBKDF2",
		false,
		["deriveBits", "deriveKey"]
	);

	const salt = crypto.getRandomValues(new Uint8Array(16));

	const derivedKey = await crypto.subtle.deriveKey(
		{
			name: "PBKDF2",
			salt: salt,
			iterations: 100000,
			hash: "SHA-256",
		} as Pbkdf2Params,
		passwordKey,
		{ name: "AES-GCM", length: 256 },
		true,
		["encrypt", "decrypt"]
	);

	const chatIds = new Set(
		await pb
			.collection("chats")
			.getFullList({
				fields: "id",
			})
			.then((records) => records.map((record) => record.id))
	);

	const localStorageLength = localStorage.length;
	requestBatch = pb.createBatch();

	requestBatch.collection("keystore").create({
		owner: thisUserId,
		type: "PBKDF2" as KeyType,
		oneTime: oneTime,
		iv: JSON.stringify(Array.from(salt)),
	});

	for (let i = 0; i < localStorageLength; i++) {
		const key = localStorage.key(i);
		const value = localStorage.getItem(key ?? "");

		if (
			(!key?.startsWith("chat_") && key !== "privateKey") ||
			value === null
		)
			continue;

		if (key === "privateKey") {
			await registerKey({
				key: value,
				keyType: ASYMMETRIC_KEY_ALG,
				encryptionKey: derivedKey,
				oneTime: oneTime,
			});
			continue;
		}

		let chatId = key.substring(5);

		if (!chatIds.has(chatId)) {
			continue;
		}

		await registerKey({
			key: value,
			keyType: SYMMETRIC_KEY_ALG,
			encryptionKey: derivedKey,
			relatedChat: chatId,
			oneTime: oneTime,
		});
	}

	try {
		await requestBatch.send();
	} catch (err) {
		alert(err);
	}

	alert("Finished uploading key(s) to the keystore.");
}

const ExportKeyPage = {
	async oninit() {
		const key = await getKey();

		if (key === null) {
			alert("You do not have a private key. ðŸ˜”");
			window.location.href = "#!/importPrivateKey";
			return;
		}

		privKey = key;
		jwk = JSON.stringify(await crypto.subtle.exportKey("jwk", privKey));
		m.redraw();
	},
	view() {
		return m("main#pagecontainer.flex-center.flex-col.gap-4", [
			m(
				"p.exclude-printing",
				"Reminder: NEVER share this with other people. Unless you want others to see your chat."
			),
			m("input#privateKey.exclude-printing", {
				readonly: true,
				type: "text",
				value: jwk,
			}),
			m(".flex.gap-2.exclude-printing", [
				m(
					"button.button",
					{
						async onclick() {
							await navigator.clipboard.writeText(jwk);
							alert("Copied!");
						},
					},
					"Copy"
				),
				m(
					"a.cleanlink.button",
					{
						href: `data:application/json;charset=utf-8,${encodeURIComponent(
							jwk
						)}`,
						download: "litechat_privatekey.json",
					},
					"Download"
				),
				m(
					"button.button",
					{
						onclick() {
							const dialog = document.getElementById(
								"printDialog"
							) as HTMLDialogElement;
							dialog.showModal();
							setTimeout(() => {
								print();
								dialog.close();
							}, 250);
						},
					},
					"Print"
				),
				m(
					"button.button",
					{
						onclick: useKeystore,
					},
					"Keystore"
				),
			]),
			m(
				"dialog#printDialog",
				{
					style: "height: 90%; width: 90%; overflow-wrap: break-word; word-break: break-all;",
				},
				[
					m(
						"p",
						{
							style: "font-weight: 700;text-align: center;",
						},
						"litechat RSA Private key. NEVER share this document, keep this confidential."
					),
					m(
						"div",
						{
							style: "font-size: 0.95em;",
						},
						jwk
					),
				]
			),
		]);
	},
} as Component;

export default ExportKeyPage;
